import java.io.*;
import java.util.*;
import java.sql.*;
import java.net.*;
import org.json.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

//Requires a  jdbc driver and Org.Json

public class ServiceRanker {
    /*
    (1) - First line of service_filter_input.txt contains service type to be filtered. - shelter, employment, event, food
    (2) - Second line of input file must contain the user location.
    (3) - Third Line specifies whether services must be open now. If true then set to 'opennow', otherwise 'anytime'.
    (4) - Fourth and following lines contain filter types and filter value seperated by a comma e.g:

        shelter
        2500 American River Drive, Sacramento, California, USA
        opennow
        filter,1

        ALTERNATIVELY AS AN EXAMPLE:

        employment
        6000 J St, Sacramento, CA 95819
        anytime
        filter,0

    each filter label and service name must match its corresponding label in the database. */

    //RENAME FILE PATH
    static String service_filter_input_file = "C:\\Users\\Karanbir\\service_rank\\src\\service_filter_input.txt";

    /* Output file contains a ranked list of services starting from the closest to user.
       Each line contains all information about a service seperated by commas, e.g:

    service name, location, description, phone number, opening time, closing time, 3.4 miles
    service name, location, description, phone number, opening time, closing time, 4.6 miles
    service name, location, description, phone number, opening time, closing time, 6.3 miles
    .
    .
    .
     */
    static String ranked_service_output_file = "C:\\Users\\Karanbir\\service_rank\\src\\service_filter_output.txt";

    //Stores filters generated by user
    public static class ServiceFilter {
        String filter_label;
        boolean value;
        public ServiceFilter(String fl, boolean v) {
            this.filter_label = fl;
            this.value = v;
        }
    }

    //Stores valid service names and associated properties to be returned:
    public static class Service {
        String name;
        String location;
        String description;
        String phone;
        String opening_time;
        String closing_time;
        String distance_from_user_in_miles;
    }

    //Custom service comparator:
    static class SortByDistance implements Comparator<Service> {
        public int compare(Service s1, Service s2)
        {
            float d1 = Float.parseFloat(s1.distance_from_user_in_miles);
            float d2 = Float.parseFloat(s2.distance_from_user_in_miles);
            if(d1 == d2) {
                return 0;
            }
            return d1 > d2 ? 1 : -1;
        }
    }

    //Transfers input file to string list, each entry is a line of the input file:
    private static ArrayList<String> load_input_file() {
        ArrayList<String> input_file = new ArrayList<String>();
        try(BufferedReader br = new BufferedReader(new FileReader(service_filter_input_file))) {
            String line;
            while((line = br.readLine()) != null) {
                input_file.add(line);
            }
        } catch (IOException e) {
            System.out.println("Error reading service_filter_input.txt");
        }
        return input_file;
    }

    //Reads lines 4 until last-line of input file and returns filters with associated values:
    private static ArrayList<ServiceFilter> get_filters(ArrayList<String> input_file) {
        ArrayList<ServiceFilter> filters = new ArrayList<ServiceFilter>();
        for(int i = 3; i < input_file.size(); i++) {
            String[] filter_and_val = input_file.get(i).split(",", 2);
            filters.add(new ServiceFilter(filter_and_val[0], (Objects.equals(filter_and_val[1], "1")) ));
        }
        return filters;
    }

    /* Retrieves service data of user specified service type from database and compares their associated properties
       against user filters, returns a list of services that satisfy filter constraints and 'opennow' constraint.
       Distance property is not specified until later, returned service list is unsorted. */
    private static ArrayList<Service> get_valid_services(ArrayList<ServiceFilter> filters, String service_type, boolean open_now) {
        ArrayList<Service> valid_services = new ArrayList<Service>();

        try{
            Class.forName("com.mysql.cj.jdbc.Driver");

            //Retrieving service information from database:
            String url       =   "jdbc:mysql://sql3.freesqldatabase.com:3306/sql3703308";
            String username  =   "sql3703308";
            String password  =   "4fbgM2Vt2F";
            Connection connection = DriverManager.getConnection(url, username, password);
            Statement statement = connection.createStatement();
            ResultSet result_set = statement.executeQuery("SELECT * FROM " + service_type);

            // Compare services to filters and append to list if valid:
            while (result_set.next()) {

                boolean is_valid = true;

                //Filtering by opening time and closing time relative to current time:
                if(open_now) {
                    String opening_time = result_set.getString("opening");
                    String closing_time = result_set.getString("closing");

                    if(opening_time != null && closing_time != null) {
                        LocalTime ot = LocalTime.parse(opening_time);
                        LocalTime ct = LocalTime.parse(closing_time);

                        //Checking whether current time falls withing opening and closing window:
                        LocalTime current_time = LocalTime.now();
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
                        is_valid &= current_time.isAfter(ot) && current_time.isBefore(ct);
                    }
                }

                //Filtering by properties:
                for(ServiceFilter f: filters) {
                    int service_attribute_value = result_set.getInt(f.filter_label);

                    //If user filter is set to 1 then service attribute must also be 1:
                    is_valid &= !f.value || (service_attribute_value == 1);
                }

                //Appending if valid and setting service properties:
                if(is_valid) {
                    valid_services.add(new Service());

                    //Setting properties of service:
                    int index = valid_services.size() - 1;
                    valid_services.get(index).name          = result_set.getString("name");
                    valid_services.get(index).location      = result_set.getString("location");
                    valid_services.get(index).description   = result_set.getString("description");
                    valid_services.get(index).phone         = result_set.getString("phone");
                    valid_services.get(index).opening_time  = result_set.getString("opening");
                    valid_services.get(index).closing_time  = result_set.getString("closing");
                }
            }

            //Close connection:
            result_set.close();
            statement.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return valid_services;
    }

    // Calculates distance of each service relative to user using the Google Maps API
    private static void get_service_distance_from_user(ArrayList<Service> services, String user_location) {
        if(!services.isEmpty()) {
            try {

                // Construct API request URL
                String destinations = "";
                for (Service s : services) {
                    destinations += URLEncoder.encode(s.location, "UTF-8") + '|';
                }

                //Remove extraneous '|':
                destinations = destinations.substring(0, destinations.length() - 1);
                user_location = URLEncoder.encode(user_location, "UTF-8");
                String unit = "imperial";
                String api_key = "AIzaSyAmjnQQ3pDlKtbmuNqZKQBYTJE3wbgG2RA";

                String url_string = "https://maps.googleapis.com/maps/api/distancematrix/json" +
                        "?destinations=" + destinations +
                        "&origins=" + user_location +
                        "&units=" + unit +
                        "&key=" + api_key;
                URL url = new URL(url_string);

                // Create connection with Google Distance Matrix API:
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod("GET");

                //Loading response from API:
                BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
                String response = "";
                String line;
                while ((line = reader.readLine()) != null) {
                    response += line;
                }
                reader.close();

                //Parsing JSON response and loading distance metric into service list:
                load_distance_into_service_list(services, response);

                // Closing Distance Matrix API connection:
                connection.disconnect();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    //Parses JSON response and loads distance metric into service list:
    private static void load_distance_into_service_list(ArrayList<Service> services, String response) {
        JSONObject json_response = new JSONObject(response);
        JSONArray json_rows = json_response.getJSONArray("rows");
        JSONArray json_elements = json_rows.getJSONObject(0).getJSONArray("elements");

        /*Iterating through elements of the response - each element contains a distance, duration and status
          field associated with each possible service destination */
        for (int i = 0; i < json_elements.length(); i++) {
            JSONObject element = json_elements.getJSONObject(i);
            String distance = element.getJSONObject("distance").getString("text");

            //Removing " mi" suffix:
            distance = distance.substring(0, distance.length() - 3);
            services.get(i).distance_from_user_in_miles = distance;
        }
    }

    private static void write_ranked_service_list_to_output(ArrayList<Service> services) {
        try(BufferedWriter bw = new BufferedWriter(new FileWriter(ranked_service_output_file))) {

            //Write service properties seperated by '|' to output:
            for(Service s: services) {
                bw.write(s.name + "|");
                bw.write(s.location + "|");
                bw.write(s.description + "|");
                bw.write(s.phone + "|");
                bw.write(s.opening_time + "|");
                bw.write(s.closing_time + "|");
                bw.write(s.distance_from_user_in_miles + " miles\n");
            }
        } catch (IOException e) {
            System.out.println("Error writing to service_filter_output.txt");
        }
    }

    public static void main(String[] args) {

        //Loading user generated info in input file:
        ArrayList<String> input_file        = load_input_file();
        String service_type                 = input_file.get(0);
        String user_location                = input_file.get(1);
        boolean open_now                    = input_file.get(2).equals("opennow");
        ArrayList<ServiceFilter> filters    = get_filters(input_file);

        //Generating an unsorted list of services that match user filters:
        ArrayList<Service> services = get_valid_services(filters, service_type, open_now);

        //Calculating distance between user and services:
        get_service_distance_from_user(services, user_location);

        //Sorting service list by distance relative to user:
        Collections.sort(services, new SortByDistance());

        //Writing sorted service list to output file:
        write_ranked_service_list_to_output(services);
    }
}
