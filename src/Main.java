import java.io.*;
import java.util.*;
import java.sql.*;
import java.net.*;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

//Requires a  jdbc driver

public class Main {
    /*
    (1) - First line of service_filter_input.txt contains service type to be filtered. - sheltersac, employmentsac, eventsac, foodsac
    (2) - Second Line specifies whether services must be open now. If true then set to 'opennow', otherwise 'anytime'.
    (3) - Third and following lines contain filter types and filter value seperated by a comma e.g:

        sheltersac
        opennow
        filter,1

        ALTERNATIVELY AS AN EXAMPLE:

        employmentsac
        anytime
        filter,0

    each filter label and service name must match its corresponding label in the database. */

    //RENAME FILE PATH
    static String service_filter_input_file = "C:\\Users\\Karanbir\\service_rank\\src\\service_filter_input.txt";

    /* Output file contains a ranked list of services starting from the closest to user.
       Each line contains all information about a service seperated by commas, e.g:

    service name, location, description, phone number, opening time, closing time, 3.4 miles
    service name, location, description, phone number, opening time, closing time, 4.6 miles
    service name, location, description, phone number, opening time, closing time, 6.3 miles
    .
    .
    .
     */
    static String ranked_service_output_file = "C:\\Users\\Karanbir\\service_rank\\src\\service_filter_output.txt";

    //Stores filters generated by user
    public static class ServiceFilter {
        String filter_label;
        boolean value;
        public ServiceFilter(String fl, boolean v) {
            this.filter_label = fl;
            this.value = v;
        }
    }

    //Stores valid service names and associated properties to be returned:
    public static class Service {
        String name;
        String location;
        String description;
        String phone;
        String opening_time;
        String closing_time;
        int distance_from_user_in_miles;
    }

    //Custom service comparator:
    static class SortByDistance implements Comparator<Service> {
        public int compare(Service s1, Service s2)
        {
            if(s1.distance_from_user_in_miles == s2.distance_from_user_in_miles) {
                return 0;
            }
            return s1.distance_from_user_in_miles < s2.distance_from_user_in_miles ? 1 : -1;
        }
    }

    //Reads first line of service_filters.txt and returns service type:
    private static String get_service_type() {
        String service_type = null;
        try(BufferedReader br = new BufferedReader(new FileReader(service_filter_input_file))) {
            service_type = br.readLine();
        } catch (IOException e) {
            System.out.println("Error reading service_filter_input.txt");
        }
        return service_type;
    }

    //Reads second line of service_filters.txt and returns whether service must be open now:
    private static boolean get_open_now() {
        boolean open_now = false;
        try(BufferedReader br = new BufferedReader(new FileReader(service_filter_input_file))) {

            //Skipping first line:
            br.readLine();

            open_now = br.readLine().equals("opennow");
        } catch (IOException e) {
            System.out.println("Error reading service_filter_input.txt");
        }
        return open_now;
    }

    //Reads lines 3 until last-line of service_filter_input.txt and returns filters with associated values:
    private static ArrayList<ServiceFilter> get_filters() {
        ArrayList<ServiceFilter> filters = new ArrayList<ServiceFilter>();
        try(BufferedReader br = new BufferedReader(new FileReader(service_filter_input_file))) {

            //Skipping first two lines
            br.readLine();
            br.readLine();

            String line;
            while ((line = br.readLine()) != null) {
                String[] filter_and_val = line.split(",", 2);
                filters.add(new ServiceFilter(filter_and_val[0], Boolean.parseBoolean(filter_and_val[1])));
            }
        } catch (IOException e) {
            System.out.println("Error reading service_filter_input.txt");
            e.printStackTrace();
        }
        return filters;
    }

    /* Retrieves service data of user specified service type from database and compares their associated properties
       against user filters, returns a list of services that satisfy filter constraints and 'opennow' constraint.
       Distance property is not specified until later, returned service list is unsorted. */
    private static ArrayList<Service> get_valid_services(ArrayList<ServiceFilter> filters, String service_type, boolean open_now) {
        ArrayList<Service> valid_services = new ArrayList<Service>();

        try{
            Class.forName("com.mysql.cj.jdbc.Driver");

            //Retrieving service information from database:
            String url       =   "jdbc:mysql://sql3.freesqldatabase.com:3306/sql3703308";
            String username  =   "sql3703308";
            String password  =   "4fbgM2Vt2F";
            Connection connection = DriverManager.getConnection(url, username, password);
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement.executeQuery("SELECT * FROM " + service_type);

            // Compare services to filters and append to list if valid:
            while (resultSet.next()) {

                boolean is_valid = true;

                //Filtering by opening time and closing time relative to current time:
                if(open_now) {

                    //Getting opening and closing time in HH:MM:SS format:
                    LocalTime opening_time = LocalTime.parse(resultSet.getString("opening"));
                    LocalTime closing_time = LocalTime.parse(resultSet.getString("closing"));

                    //Checking whether current time falls withing opening and closing window:
                    LocalTime current_time = LocalTime.now();
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm:ss");
                    is_valid &= current_time.isAfter(opening_time) && current_time.isBefore(closing_time);
                }

                //Filtering by properties:
                for(ServiceFilter f: filters) {
                    int service_attribute_value = resultSet.getInt(f.filter_label);

                    //If user filter is set to 1 then service attribute must also be 1:
                    is_valid &= !f.value || (service_attribute_value == 1);
                }

                //Appending if valid and setting service properties:
                if(is_valid) {
                    valid_services.add(new Service());

                    //Setting properties of service:
                    int index = valid_services.size() - 1;
                    valid_services.get(index).name          = resultSet.getString("name");
                    valid_services.get(index).location      = resultSet.getString("location");
                    valid_services.get(index).description   = resultSet.getString("description");
                    valid_services.get(index).phone         = resultSet.getString("phone");
                    valid_services.get(index).opening_time  = resultSet.getString("opening");
                    valid_services.get(index).closing_time  = resultSet.getString("closing");
                }
            }

            //Close connection:
            resultSet.close();
            statement.close();
            connection.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return valid_services;
    }

    /* Calculates distance of each service relative to user using the Google Maps API */
    private static ArrayList<Service> get_service_distance_from_user(ArrayList<Service> services, String user_location) {
        /* String destinations = URLEncoder.encode(user_location, "UTF-8");
        for(Service s: services) {

        }
        try {

            // Construct API request URL
            String destinations = URLEncoder.encode(user_location, "UTF-8");
            String origin = URLEncoder.encode(user_location, "UTF-8");
            String units = "imperial";
            String api_key = "AIzaSyAmjnQQ3pDlKtbmuNqZKQBYTJE3wbgG2RA";
            String url_string = "https://maps.googleapis.com/maps/api/distancematrix/json" +
                                "?destinations="    + destinations  +
                                "&origins="         + origin        +
                                "&units="           + units         +
                                "&key="             + api_key;
            URL url = new URL(url_string);

            // Create a connection
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod("GET");

            // Read the response
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            StringBuilder response = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            reader.close();

            // Parse the JSON response
            JSONObject jsonResponse = new JSONObject(response.toString());
            JSONArray rows = jsonResponse.getJSONArray("rows");
            JSONObject elements = rows.getJSONObject(0).getJSONArray("elements").getJSONObject(0);
            String distance = elements.getJSONObject("distance").getString("text");

            // Print the distance in miles
            System.out.println("Distance: " + distance);

            // Close the connection
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        } */
        return services;
    }

    private static void write_ranked_service_list_to_output(ArrayList<Service> services) {
        try(BufferedWriter bw = new BufferedWriter(new FileWriter(ranked_service_output_file))) {

            //Write service properties seperated by commas to output:
            for(Service s: services) {
                bw.write(s.name + ",");
                bw.write(s.location + ",");
                bw.write(s.description + ",");
                bw.write(s.phone + ",");
                bw.write(s.opening_time + ",");
                bw.write(s.closing_time + ",");
                bw.write(s.distance_from_user_in_miles + " miles\n");
            }
        } catch (IOException e) {
            System.out.println("Error writing to service_filter_output.txt");
        }
    }

    public static void main(String[] args) {

        //Specifying service type to be filtered
        String service_type = get_service_type();

        //Specifying whether returned services must be open now:
        boolean open_now = get_open_now();

        //Specifying filters
        ArrayList<ServiceFilter> filters = get_filters();

        //Generating an unsorted list of services that match user filters:
        ArrayList<Service> services = get_valid_services(filters, service_type, open_now);

        //Calculating relative distance between user and services:
        String user_location = "";
        get_service_distance_from_user(services, user_location);

        //Sorting service list by distance relative to user:
        Collections.sort(services, new SortByDistance());

        //Writing sorted service list to output file:
        write_ranked_service_list_to_output(services);
    }
}
